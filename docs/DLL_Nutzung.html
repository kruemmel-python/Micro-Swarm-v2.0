<!DOCTYPE html>
<html lang="de" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Konvertiertes Dokument</title>
  
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Fira+Code&display=swap');
  
  :root {
    --bg-color: #1a202c;
    --text-color: #cbd5e0;
    --heading-color: #cbd5e0;
    --border-color: #4a5568;
    --link-color: #63b3ed;
    --link-hover-color: #90cdf4;
    --code-bg-color: rgba(0, 0, 0, 0.2);
    --blockquote-color: #a0aec0;
  }

  body { 
    background-color: var(--bg-color); 
    color: var(--text-color);
    font-family: 'Inter', sans-serif;
    font-size: 16px;
    line-height: 1.7;
    margin: 0;
    padding: 2rem;
    display: grid;
    place-items: center;
    min-height: 100vh;
  }
  main {
    width: 100%;
    max-width: 800px; /* Limits content width for readability */
  }
  h1, h2, h3, h4, h5, h6 {
    color: var(--heading-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.3em;
    margin-top: 1.5em;
    margin-bottom: 1em;
  }
  a {
    color: var(--link-color);
    text-decoration: none;
    transition: color 0.3s;
  }
  a:hover {
    color: var(--link-hover-color);
    text-decoration: underline;
  }
  img { 
    max-width: 100%; 
    height: auto; 
    display: block; 
    margin: 1.5rem auto; 
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    background-color: var(--code-bg-color); /* BG for transparent images */
  }
  p {
    margin-bottom: 1em;
  }
  pre {
    background-color: var(--code-bg-color);
    color: var(--heading-color);
    padding: 1rem;
    border-radius: 8px;
    overflow-x: auto;
    border: 1px solid var(--border-color);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }
  code { 
    font-family: 'Fira Code', 'Courier New', Courier, monospace;
    background-color: var(--code-bg-color);
    padding: 0.2em 0.4em;
    border-radius: 4px;
    font-size: 0.9em;
  }
  pre > code {
    background-color: transparent;
    padding: 0;
    border-radius: 0;
    font-size: 1em;
  }
  table { 
    border-collapse: collapse; 
    width: 100%; 
    margin: 1.5rem 0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    border-radius: 8px;
    overflow: hidden;
  }
  th, td { 
    border: 1px solid var(--border-color);
    padding: 0.75rem;
    text-align: start;
  }
  th {
    background-color: var(--code-bg-color);
    color: var(--heading-color);
    font-weight: bold;
  }
  blockquote {
    border-inline-start: 4px solid var(--link-color);
    padding-inline-start: 1rem;
    margin-inline-start: 0;
    margin-right: 0;
    margin-block: 1.5em;
    color: var(--blockquote-color);
    font-style: italic;
  }
  ul, ol {
    padding-inline-start: 2rem;
  }
  li {
    margin-bottom: 0.5em;
  }
</style>

</head>
<body>
  <main>
    <h1>Nutzung der Micro-Swarm DLL</h1>
<p>Die DLL stellt eine vollstaendige C-API bereit (FFI-sicher) und kann aus Python, Rust oder anderen Sprachen aufgerufen werden.</p>
<p>Dateien:</p>
<ul>
<li><code>micro_swarm.dll</code> (Windows) bzw. <code>libmicro_swarm.so</code> (Linux)</li>
<li><code>src/micro_swarm_api.h</code> (C-API Header)</li>
</ul>
<h2>Wichtiges Grundprinzip</h2>
<ul>
<li>Alle Funktionen sind synchron, kein internes Threading.</li>
<li>Alle Structs sind POD und <code>repr(C)</code> kompatibel.</li>
<li>Felder werden als <code>float*</code> im Row-Major-Format genutzt (<code>width * height</code>).</li>
<li>Ownership: <code>ms_create()</code> liefert einen Handle, der mit <code>ms_destroy()</code> freigegeben wird.</li>
<li>Calling Convention (Windows): <strong>__cdecl</strong> (Standard-C). In Python daher <code>ct.CDLL</code> verwenden.</li>
<li>Packing: Es wird <strong>kein</strong> spezielles <code>#pragma pack</code> verwendet (Default-Alignment).</li>
<li>Thread-Safety: Ein Kontext ist <strong>nicht</strong> thread-safe; parallele Calls auf denselben Handle sind undefiniert.</li>
<li>Thread-Ownership: Ein Kontext darf von genau einem Thread gleichzeitig benutzt werden; Uebergabe zwischen Threads ist erlaubt, parallele Nutzung nicht.</li>
</ul>
<h3>Rueckgabewerte / Fehler</h3>
<ul>
<li>Funktionen mit <code>int</code>-Rueckgabe liefern <strong>0 bei Fehler</strong> (oder 0 Elemente), <strong>&gt;0 bei Erfolg</strong>.</li>
<li><code>ms_step/ms_run</code> liefern die ausgefuehrten Schritte (0 bei Fehler/ungueligem Handle).</li>
<li><code>ms_copy_field_in/out</code> erwarten <code>count</code> als <strong>Anzahl Floats</strong> (nicht Bytes).</li>
<li><code>ms_get_field_info</code> gibt <code>w/hgt</code> aus, hat <strong>keinen</strong> Returncode.</li>
</ul>
<h4>Returncode-Tabelle (aktuell)</h4>
<table>
<thead>
<tr>
<th>Code</th>
<th>Bedeutung</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt; 0</td>
<td>Erfolg (z. B. Anzahl geschriebener Elemente oder Schritte)</td>
</tr>
<tr>
<td>0</td>
<td>Fehler (generic failure / ungueltige Eingaben)</td>
</tr>
</tbody>
</table>
<h3>Struct-Groesse / ABI-Hinweis</h3>
<ul>
<li>Die Struct-Groessen muessen mit dem verwendeten <code>micro_swarm_api.h</code> uebereinstimmen.</li>
<li>Es gibt <strong>keine</strong> automatische Ignorierung zusaetzlicher Felder.</li>
</ul>
<h3>Field-IDs (Enum)</h3>
<pre><code>0 = RESOURCES
1 = PHEROMONE_FOOD
2 = PHEROMONE_DANGER
3 = MOLECULES
4 = MYCEL
</code></pre>
<h3>DLL-Suche (Windows)</h3>
<p>Die DLL muss sich im Arbeitsverzeichnis, neben dem Python-Script oder im <code>PATH</code> befinden.</p>
<h3>OpenCL-Hinweis</h3>
<p>OpenCL muss auf dem Zielsystem installiert/verfuegbar sein, wenn GPU-Funktionen genutzt werden. Ohne OpenCL faellt die DLL automatisch auf CPU zurueck.</p>
<h3>Lifecycle-Hinweis</h3>
<p><code>ms_get_field_info</code>, <code>ms_copy_field_out</code> und <code>ms_copy_field_in</code> sind nur zwischen <code>ms_create</code> und <code>ms_destroy</code> gueltig.</p>
<hr>
<h2>MycoDB (Datenbank) API</h2>
<p>Die MycoDB-Funktionen sind in der DLL verfuegbar und nutzen einen separaten Handle:</p>
<ul>
<li><code>ms_db_create()</code> / <code>ms_db_destroy()</code></li>
<li><code>ms_db_load_sql()</code> / <code>ms_db_run_ingest()</code> / <code>ms_db_save_myco()</code> / <code>ms_db_load_myco()</code></li>
<li><code>ms_db_query_sql()</code> / <code>ms_db_query_simple()</code> / <code>ms_db_query_by_id()</code></li>
<li>Fokus-Varianten: <code>ms_db_query_simple_focus()</code> / <code>ms_db_query_by_id_focus()</code></li>
<li>Ergebniszugriff: <code>ms_db_get_result_count()</code>, <code>ms_db_get_result_indices()</code>, <code>ms_db_get_payload()</code>, <code>ms_db_get_payload_raw()</code></li>
<li>Hilfen: <code>ms_db_find_payload_by_id()</code>, <code>ms_db_get_payload_count()</code>, <code>ms_db_get_table_count()</code></li>
</ul>
<p>Fehlertexte koennen ueber <code>ms_db_get_last_error()</code> abgefragt werden.</p>
<p>Ein komplettes C# Beispiel findest du in <code>examples/MycoDbExample.cs</code>.</p>
<hr>
<h2>Python (ctypes) Beispiel (robust)</h2>
<pre><code class="language-python">import ctypes as ct
from pathlib import Path

DLL_PATH = Path(r&quot;.\build\Release\micro_swarm.dll&quot;)

# WICHTIG:
# - __cdecl: ct.CDLL (Standard-C)
# - __stdcall: ct.WinDLL
lib = ct.CDLL(str(DLL_PATH))

class MicroSwarmError(RuntimeError):
    pass

def _check_rc(rc: int, fn_name: str) -&gt; int:
    if rc &lt;= 0:
        raise MicroSwarmError(f&quot;{fn_name} failed with rc={rc}&quot;)
    return rc

class ms_params_t(ct.Structure):
    _fields_ = [
        (&quot;width&quot;, ct.c_int),
        (&quot;height&quot;, ct.c_int),
        (&quot;agent_count&quot;, ct.c_int),
        (&quot;steps&quot;, ct.c_int),
        (&quot;pheromone_evaporation&quot;, ct.c_float),
        (&quot;pheromone_diffusion&quot;, ct.c_float),
        (&quot;molecule_evaporation&quot;, ct.c_float),
        (&quot;molecule_diffusion&quot;, ct.c_float),
        (&quot;resource_regen&quot;, ct.c_float),
        (&quot;resource_max&quot;, ct.c_float),
        (&quot;mycel_decay&quot;, ct.c_float),
        (&quot;mycel_growth&quot;, ct.c_float),
        (&quot;mycel_transport&quot;, ct.c_float),
        (&quot;mycel_drive_threshold&quot;, ct.c_float),
        (&quot;mycel_drive_p&quot;, ct.c_float),
        (&quot;mycel_drive_r&quot;, ct.c_float),
        (&quot;agent_move_cost&quot;, ct.c_float),
        (&quot;agent_harvest&quot;, ct.c_float),
        (&quot;agent_deposit_scale&quot;, ct.c_float),
        (&quot;agent_sense_radius&quot;, ct.c_float),
        (&quot;agent_random_turn&quot;, ct.c_float),
        (&quot;dna_capacity&quot;, ct.c_int),
        (&quot;dna_global_capacity&quot;, ct.c_int),
        (&quot;dna_survival_bias&quot;, ct.c_float),
        (&quot;phero_food_deposit_scale&quot;, ct.c_float),
        (&quot;phero_danger_deposit_scale&quot;, ct.c_float),
        (&quot;danger_delta_threshold&quot;, ct.c_float),
        (&quot;danger_bounce_deposit&quot;, ct.c_float),
        (&quot;evo_enable&quot;, ct.c_int),
        (&quot;evo_elite_frac&quot;, ct.c_float),
        (&quot;evo_min_energy_to_store&quot;, ct.c_float),
        (&quot;evo_mutation_sigma&quot;, ct.c_float),
        (&quot;evo_exploration_delta&quot;, ct.c_float),
        (&quot;evo_fitness_window&quot;, ct.c_int),
        (&quot;evo_age_decay&quot;, ct.c_float),
        (&quot;global_spawn_frac&quot;, ct.c_float),
    ]

class ms_config_t(ct.Structure):
    _fields_ = [(&quot;params&quot;, ms_params_t), (&quot;seed&quot;, ct.c_uint32)]

ms_handle_t = ct.c_void_p

lib.ms_create.argtypes = [ct.POINTER(ms_config_t)]
lib.ms_create.restype = ms_handle_t

lib.ms_destroy.argtypes = [ms_handle_t]
lib.ms_destroy.restype = None

lib.ms_step.argtypes = [ms_handle_t, ct.c_int]
lib.ms_step.restype = ct.c_int

lib.ms_get_field_info.argtypes = [ms_handle_t, ct.c_int, ct.POINTER(ct.c_int), ct.POINTER(ct.c_int)]
lib.ms_get_field_info.restype = None

lib.ms_copy_field_out.argtypes = [ms_handle_t, ct.c_int, ct.POINTER(ct.c_float), ct.c_int]
lib.ms_copy_field_out.restype = ct.c_int

cfg = ms_config_t()
cfg.params.width = 128
cfg.params.height = 128
cfg.params.agent_count = 512
cfg.params.steps = 100
cfg.seed = 42

ctx = lib.ms_create(ct.byref(cfg))
if not ctx:
    raise MicroSwarmError(&quot;ms_create returned NULL&quot;)

rc = lib.ms_step(ctx, 10)
_check_rc(rc, &quot;ms_step&quot;)

w = ct.c_int()
hgt = ct.c_int()
MS_FIELD_PHEROMONE_FOOD = 1
lib.ms_get_field_info(ctx, MS_FIELD_PHEROMONE_FOOD, ct.byref(w), ct.byref(hgt))
count = w.value * hgt.value
buffer = (ct.c_float * count)()
rc = lib.ms_copy_field_out(ctx, MS_FIELD_PHEROMONE_FOOD, buffer, count)
_check_rc(rc, &quot;ms_copy_field_out&quot;)

lib.ms_destroy(ctx)
</code></pre>
<hr>
<h2>Rust (FFI) Beispiel</h2>
<pre><code class="language-rust">#[repr(C)]
pub struct ms_params_t {
    width: i32,
    height: i32,
    agent_count: i32,
    steps: i32,
    pheromone_evaporation: f32,
    pheromone_diffusion: f32,
    molecule_evaporation: f32,
    molecule_diffusion: f32,
    resource_regen: f32,
    resource_max: f32,
    mycel_decay: f32,
    mycel_growth: f32,
    mycel_transport: f32,
    mycel_drive_threshold: f32,
    mycel_drive_p: f32,
    mycel_drive_r: f32,
    agent_move_cost: f32,
    agent_harvest: f32,
    agent_deposit_scale: f32,
    agent_sense_radius: f32,
    agent_random_turn: f32,
    dna_capacity: i32,
    dna_global_capacity: i32,
    dna_survival_bias: f32,
    phero_food_deposit_scale: f32,
    phero_danger_deposit_scale: f32,
    danger_delta_threshold: f32,
    danger_bounce_deposit: f32,
    evo_enable: i32,
    evo_elite_frac: f32,
    evo_min_energy_to_store: f32,
    evo_mutation_sigma: f32,
    evo_exploration_delta: f32,
    evo_fitness_window: i32,
    evo_age_decay: f32,
    global_spawn_frac: f32,
}

#[repr(C)]
pub struct ms_config_t {
    params: ms_params_t,
    seed: u32,
}

extern &quot;C&quot; {
    fn ms_create(cfg: *const ms_config_t) -&gt; *mut std::ffi::c_void;
    fn ms_destroy(h: *mut std::ffi::c_void);
    fn ms_step(h: *mut std::ffi::c_void, steps: i32) -&gt; i32;
}

fn main() {
    let mut cfg = ms_config_t { params: unsafe { std::mem::zeroed() }, seed: 42 };
    cfg.params.width = 128;
    cfg.params.height = 128;
    cfg.params.agent_count = 512;
    cfg.params.steps = 100;
    unsafe {
        let h = ms_create(&amp;cfg);
        if h.is_null() {
            panic!(&quot;ms_create returned NULL&quot;);
        }
        let rc = ms_step(h, 10);
        if rc &lt;= 0 {
            ms_destroy(h);
            panic!(&quot;ms_step failed rc={rc}&quot;);
        }
        ms_destroy(h);
    }
}
</code></pre>
<hr>
<h2>C Minimalbeispiel (ABI Ground Truth)</h2>
<pre><code class="language-c">#include &quot;micro_swarm_api.h&quot;

int main(void) {
    ms_config_t cfg = {0};
    cfg.params.width = 128;
    cfg.params.height = 128;
    cfg.params.agent_count = 512;
    cfg.seed = 42;

    ms_handle_t *h = ms_create(&amp;cfg);
    if (!h) return 1;
    if (ms_step(h, 10) &lt;= 0) return 2;
    ms_destroy(h);
    return 0;
}
</code></pre>
<hr>
<h2>Ownership / Hinweise</h2>
<ul>
<li><code>ms_create()</code> erzeugt den Kontext und initialisiert Felder + Agenten.</li>
<li><code>ms_destroy()</code> MUSS immer aufgerufen werden.</li>
<li><code>ms_copy_field_in/out</code> arbeitet mit rohen Float-Arrays.</li>
<li><code>ms_ocl_enable()</code> kann die GPU-Diffusion aktivieren (falls OpenCL vorhanden).</li>
</ul>

  </main>
</body>
</html>