<!DOCTYPE html>
<html lang="de" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Konvertiertes Dokument</title>
  
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Fira+Code&display=swap');
  
  :root {
    --bg-color: #1a202c;
    --text-color: #cbd5e0;
    --heading-color: #cbd5e0;
    --border-color: #4a5568;
    --link-color: #63b3ed;
    --link-hover-color: #90cdf4;
    --code-bg-color: rgba(0, 0, 0, 0.2);
    --blockquote-color: #a0aec0;
  }

  body { 
    background-color: var(--bg-color); 
    color: var(--text-color);
    font-family: 'Inter', sans-serif;
    font-size: 16px;
    line-height: 1.7;
    margin: 0;
    padding: 2rem;
    display: grid;
    place-items: center;
    min-height: 100vh;
  }
  main {
    width: 100%;
    max-width: 800px; /* Limits content width for readability */
  }
  h1, h2, h3, h4, h5, h6 {
    color: var(--heading-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.3em;
    margin-top: 1.5em;
    margin-bottom: 1em;
  }
  a {
    color: var(--link-color);
    text-decoration: none;
    transition: color 0.3s;
  }
  a:hover {
    color: var(--link-hover-color);
    text-decoration: underline;
  }
  img { 
    max-width: 100%; 
    height: auto; 
    display: block; 
    margin: 1.5rem auto; 
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    background-color: var(--code-bg-color); /* BG for transparent images */
  }
  p {
    margin-bottom: 1em;
  }
  pre {
    background-color: var(--code-bg-color);
    color: var(--heading-color);
    padding: 1rem;
    border-radius: 8px;
    overflow-x: auto;
    border: 1px solid var(--border-color);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }
  code { 
    font-family: 'Fira Code', 'Courier New', Courier, monospace;
    background-color: var(--code-bg-color);
    padding: 0.2em 0.4em;
    border-radius: 4px;
    font-size: 0.9em;
  }
  pre > code {
    background-color: transparent;
    padding: 0;
    border-radius: 0;
    font-size: 1em;
  }
  table { 
    border-collapse: collapse; 
    width: 100%; 
    margin: 1.5rem 0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.4);
    border-radius: 8px;
    overflow: hidden;
  }
  th, td { 
    border: 1px solid var(--border-color);
    padding: 0.75rem;
    text-align: start;
  }
  th {
    background-color: var(--code-bg-color);
    color: var(--heading-color);
    font-weight: bold;
  }
  blockquote {
    border-inline-start: 4px solid var(--link-color);
    padding-inline-start: 1rem;
    margin-inline-start: 0;
    margin-right: 0;
    margin-block: 1.5em;
    color: var(--blockquote-color);
    font-style: italic;
  }
  ul, ol {
    padding-inline-start: 2rem;
  }
  li {
    margin-bottom: 0.5em;
  }
</style>

</head>
<body>
  <main>
<h1>MycoDB Anleitung (Micro-Swarm)</h1>
<p>Diese Anleitung beschreibt den kompletten Workflow: von MySQL Workbench ueber den SQL-Dump bis zur Ingestion, interaktiven Abfrage und Ausgabe in Micro-Swarm (MycoDB).</p>
<h2>1a) Was MycoDB ist / was es nicht ist</h2>
<p>MycoDB ist:</p>
<ul>
<li>raeumliches Clustering + lokales Retrieval von relationalen Payloads</li>
<li>Shell-Navigation und ein SQL-Light Interpreter als Komfort-Layer</li>
<li>optimiert fuer lokale Abfragen (Radius/Fokus); globale Abfragen sind moeglich, aber konzeptionell der Worst Case.</li>
</ul>
<p>MycoDB ist nicht:</p>
<ul>
<li>keine ACID-DB, keine Transaktionen, keine Konkurrenzkontrolle</li>
<li>kein Query-Optimizer/Kostenmodell im DB-Sinne</li>
<li>keine vollstaendige SQL-Compliance</li>
<li>kein Ersatz fuer Indexstrukturen mit garantierter Worst-Case-Komplexitaet</li>
</ul>
<p>Diese Abgrenzung ist wichtig, weil &quot;DB&quot; sonst zu klassischen Postgres-Erwartungen fuehrt.</p>
<h2>1) Voraussetzungen</h2>
<ul>
<li>MySQL Workbench installiert</li>
<li>Micro-Swarm gebaut (Release-Binary)</li>
<li>Genug freier Speicher fuer Dump und .myco Datei</li>
</ul>
<p>Empfohlene Struktur im Projektordner:</p>
<pre><code>./
  build/Release/micro_swarm.exe
  data/
    dump.sql
    shop.myco
    clusters.ppm
</code></pre>
<h2>1b) Datenvolumen und Komplexitaet (kurz)</h2>
<p>Speicherkosten skalieren grob mit <code>payload_count</code>, der Grid-Groesse (<code>size * size</code>) und Ergebnis-Buffer groessen (Trefferlisten). <code>--size</code> erhoeht die Grid-Flaeche quadratisch (256 -&gt; 512 = 4x Zellen). Lokale Queries skalieren mit Radius und Cluster-Dichte; <code>--db-radius</code> steuert die Suchflaeche naeherungsweise quadratisch mit dem Radius (doppelt so grosser Radius ~ 4x Flaeche). Worst Case ist ein globaler Scan (z. B. grosser Radius oder Fokus aus).</p>
<h2>2) SQL-Dump in MySQL Workbench erstellen</h2>
<ol>
<li>MySQL Workbench starten.</li>
<li>Verbindung zur Datenbank oeffnen.</li>
<li>Menue: Server -&gt; Data Export.</li>
<li>Schema auswaehlen.</li>
<li>Unter Export Options:
<ul>
<li>Dump Structure and Data aktivieren.</li>
<li>Export to Self-Contained File auswaehlen.</li>
<li>Include Column Names aktivieren (wichtig fuer saubere Queries).</li>
</ul>
</li>
<li>Dateipfad waehlen, z. B. <code>C:\Users\&lt;name&gt;\Downloads\dump.sql</code>.</li>
<li>Start Export.</li>
</ol>
<p>Hinweis: Micro-Swarm liest <code>INSERT INTO ... VALUES (...)</code> Statements. Mit Spaltenliste sind Queries ueber Spaltennamen moeglich.
Wenn der Dump <code>CREATE TABLE</code> enthaelt, werden Spaltennamen automatisch aus dem Schema gelesen.</p>
<h2>3) SQL-Dump in Micro-Swarm einspielen (db_ingest)</h2>
<p>Wechsle in das Release-Verzeichnis:</p>
<pre><code class="language-powershell">cd C:\Users\&lt;name&gt;\Downloads\superpromt\micro_DB\build\Release
</code></pre>
<p>Starte die Ingestion:</p>
<pre><code class="language-powershell">.\micro_swarm.exe --mode db_ingest --input C:\path\to\dump.sql --steps 5000 --agents 512 --size 256 --output shop.myco --db-dump clusters.ppm --db-dump-scale 6
</code></pre>
<p>Parameter-Erklaerung:</p>
<ul>
<li><code>--mode db_ingest</code> aktiviert den Datenbank-Ingestion-Modus</li>
<li><code>--input</code> Pfad zum SQL-Dump</li>
<li><code>--steps</code> Anzahl der Schwarm-Schritte (mehr Schritte = staerkeres Clustering)</li>
<li><code>--agents</code> Anzahl Traeger-Agenten</li>
<li><code>--size</code> Grid-Groesse (z. B. 256x256)</li>
<li><code>--output</code> Ziel .myco Datei</li>
<li><code>--db-dump</code> optionales PPM-Bild der Cluster</li>
<li><code>--db-dump-scale</code> vergroessert das Bild (z. B. 6 = 6x groesser)</li>
</ul>
<p>Erwartete Ausgabe:</p>
<pre><code>ingest_done payloads=&lt;N&gt; tables=&lt;T&gt;
</code></pre>
<h2>3a) Reproduzierbare Runs (golden path)</h2>
<p>Empfohlene Konfiguration fuer reproduzierbare Reports:</p>
<ul>
<li>fixer SQL-Dump (gleiche Datei, gleiche Reihenfolge)</li>
<li>feste Parameter: <code>--seed</code>, <code>--size</code>, <code>--agents</code>, <code>--steps</code></li>
<li>feste Query-Parameter: <code>--db-radius</code> bzw. <code>radius</code> in der Shell</li>
<li>falls GPU/OpenCL aktiv ist, koennen numerische Abweichungen auftreten; fuer strikte Replays GPU nicht aktivieren oder toleranzbasiert vergleichen</li>
</ul>
<p>Beispiel:</p>
<pre><code class="language-powershell">.\micro_swarm.exe --mode db_ingest --input C:\path\to\dump.sql --steps 5000 --agents 512 --size 256 --seed 42 --output shop.myco
</code></pre>
<h2>4) Cluster-Bild ansehen (optional)</h2>
<p>Das PPM-Bild zeigt die Tabellen-Cluster. Du kannst es oeffnen mit:</p>
<pre><code class="language-powershell">start clusters.ppm
</code></pre>
<p>Oder mit einem Bildbetrachter deiner Wahl.</p>
<h2>5) Interaktive Abfragen in Micro-Swarm (db_shell)</h2>
<p>Starte die Shell:</p>
<pre><code class="language-powershell">.\micro_swarm.exe --mode db_shell --db shop.myco --db-radius 5
</code></pre>
<p>Shell-Cheat-Sheet (12 Zeilen):</p>
<pre><code>tables
schema &lt;table&gt;
goto &lt;payload_id&gt;
focus
radius &lt;N&gt;
unfocus
&lt;Table&gt; &lt;PKValue&gt;
&lt;Table&gt; &lt;col&gt;=&lt;val&gt;
show &lt;col1,col2,...&gt;
sql &lt;statement&gt;
sort &lt;col|index&gt; [asc|desc] [num][, &lt;col|index&gt; [asc|desc] [num] ...]
format &lt;table|csv|json&gt;
</code></pre>
<p>Beispieleingaben:</p>
<pre><code>Album 1
Track AlbumId=1
goto 1234
radius 12
tables
stats
schema Track
Track AlbumId=1 show TrackId,Name,Milliseconds
TrackId=13
sql SELECT TrackId,Name FROM Track WHERE AlbumId=1 ORDER BY TrackId LIMIT 5
</code></pre>
<p>Bedeutung:</p>
<ul>
<li><code>Album 1</code> sucht nach Primary Key <code>AlbumId=1</code>.</li>
<li><code>Track AlbumId=1</code> sucht alle Tracks mit Foreign Key auf AlbumId.</li>
<li><code>goto 1234</code> setzt den Fokus auf Payload ID 1234.</li>
<li><code>radius 12</code> setzt den Suchradius fuer alle folgenden Anfragen.</li>
<li><code>tables</code> listet alle Tabellen.</li>
<li><code>schema &lt;table&gt;</code> zeigt bekannte Spalten.</li>
<li><code>show ...</code> filtert die Ausgabe auf Spalten.</li>
<li><code>&lt;Column&gt;=&lt;Value&gt;</code> ohne Tabellennamen sucht global.</li>
<li><code>sql &lt;statement&gt;</code> fuehrt SQL-Light aus (Phase 1).</li>
<li><code>sort &lt;col|index&gt; [asc|desc] [num][, &lt;col|index&gt; [asc|desc] [num] ...]</code> sortiert das letzte SQL-Result oder das letzte Shell-Result.</li>
<li><code>sort reset</code> stellt das letzte SQL-Result wieder her.</li>
<li><code>format &lt;table|csv|json&gt;</code> setzt das SQL-Ausgabeformat.</li>
</ul>
<p>Solange ein Fokus gesetzt ist, werden alle Suchanfragen lokal um diesen Punkt ausgefuehrt.</p>
<h2>6) Query-Format (SQL-Light, optional)</h2>
<p>Wenn du statt der Shell den Query-Modus nutzen willst:</p>
<pre><code class="language-powershell">.\micro_swarm.exe --mode db_query --db shop.myco --query &quot;SELECT * FROM Orders WHERE UserID=5&quot; --db-radius 5
</code></pre>
<p>Optional:</p>
<pre><code class="language-powershell">.\micro_swarm.exe --mode db_query --db shop.myco --query &quot;SELECT Name FROM Artist ORDER BY ArtistId LIMIT 5&quot; --sql-format csv
</code></pre>
<p>Formate:</p>
<pre><code>SELECT * FROM &lt;Table&gt; WHERE &lt;Column&gt;=&lt;Value&gt;
</code></pre>
<p>SQL-Light (Phase 1):</p>
<pre><code>SELECT &lt;cols&gt; FROM &lt;table&gt; [JOIN ...]
WHERE ... (AND/OR/NOT, IN, BETWEEN, LIKE)
GROUP BY ... HAVING ...
ORDER BY ... LIMIT ... OFFSET ...
DISTINCT, UNION, UNION ALL
RIGHT JOIN, CROSS JOIN
SUBQUERY: IN (SELECT ...), EXISTS (SELECT ...)
REGEXP, WITH (CTE)
IS NULL / IS NOT NULL
ORDER BY Spaltenindex
Funktionen: LOWER, UPPER, LENGTH, SUBSTRING, CONCAT
FROM (SELECT ...) als Subquery
</code></pre>
<p>Hinweise:</p>
<ul>
<li>Subqueries koennen aeussere Spalten referenzieren (korreliert).</li>
<li>CTEs sind <strong>nicht rekursiv</strong>.</li>
<li>Numerische Literale koennen ohne Quotes genutzt werden (z. B. <code>AlbumId=1</code>).</li>
<li><code>ORDER BY</code> sortiert numerisch, wenn beide Werte als Zahl parsebar sind.</li>
</ul>
<h2>7) Fehlerdiagnose</h2>
<ul>
<li><code>hits=0</code>:
<ul>
<li>Pruefe Tabellennamen und Spaltennamen (Gross-/Kleinschreibung egal).</li>
<li>Falls der Dump ohne Spaltenliste ist, nutze <code>Album 1</code> (Primary Key) oder <code>col0</code>.</li>
</ul>
</li>
<li><code>SQL-Fehler: Keine INSERT-Statements gefunden</code>:
<ul>
<li>Workbench Export erneut pruefen.</li>
</ul>
</li>
<li><code>MYCO-Fehler</code>:
<ul>
<li>Dateipfade und Schreibrechte pruefen.</li>
</ul>
</li>
</ul>
<h2>8) Tipps fuer gutes Clustering</h2>
<ul>
<li>Hoehere <code>--steps</code> fuer bessere Clusterbildung.</li>
<li>Groesseres Grid (<code>--size</code>) wenn viele Payloads vorhanden sind.</li>
<li><code>--agents</code> groesser als Anzahl Tabellen * 50 ist ein guter Start.</li>
</ul>
<hr>
<p>Ende.</p>

  </main>
</body>
</html>
